#!/usr/bin/python
#
# Copyright (c) 2008,2009 Citrix Systems, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation; version 2.1 only. with the special
# exception on linking described in file LICENSE.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
"""Usage:

    %(command-name)s <PIF> up
    %(command-name)s <PIF> down
    %(command-name)s [<PIF>] rewrite
    %(command-name)s --force <BRIDGE> up
    %(command-name)s --force <BRIDGE> down
    %(command-name)s --force <BRIDGE> rewrite --device=<INTERFACE> --mac=<MAC-ADDRESS> <CONFIG>

    where <PIF> is one of:
       --session <SESSION-REF> --pif <PIF-REF>
       --pif-uuid <PIF-UUID>
    and <CONFIG> is one of:
       --mode=dhcp
       --mode=static --ip=<IPADDR> --netmask=<NM> [--gateway=<GW>]

  Options:
    --session           A session reference to use to access the xapi DB
    --pif               A PIF reference within the session.
    --pif-uuid          The UUID of a PIF.
    --force             An interface name.
"""

# Notes:
# 1. Every pif belongs to exactly one network
# 2. Every network has zero or one pifs
# 3. A network may have an associated bridge, allowing vifs to be attached
# 4. A network may be bridgeless (there's no point having a bridge over a storage pif)

import XenAPI
import os, sys, getopt
import syslog
import traceback
import time
import re
from xml.dom.minidom import getDOMImplementation
from xml.dom.minidom import parse as parseXML

db = None
management_pif = None

sysfs_bonding_masters = "/sys/class/net/bonding_masters"
dbcache_file = "/var/xapi/network.dbcache"

#
# Logging.
#

def log(s):
    syslog.syslog(s)

def log_pif_action(action, pif):
    pifrec = db.get_pif_record(pif)
    rec = {}
    rec['uuid'] = pifrec['uuid']
    rec['ip_configuration_mode'] = pifrec['ip_configuration_mode']
    rec['action'] = action
    rec['pif_netdev_name'] = pif_netdev_name(pif)
    rec['message'] = "Bring %(action)s PIF %(uuid)s" % rec
    log("%(message)s: %(pif_netdev_name)s configured as %(ip_configuration_mode)s" % rec)

#
# Run external utilities
#

def run_command(command):
    log("Running command: " + ' '.join(command))
    rc = os.spawnl(os.P_WAIT, command[0], *command)
    if rc != 0:
        log("Command failed %d: " % rc + ' '.join(command))
        return False
    return True

#
# Exceptions.
#

class Usage(Exception):
    def __init__(self, msg):
        Exception.__init__(self)
        self.msg = msg

class Error(Exception):
    def __init__(self, msg):
        Exception.__init__(self)
        self.msg = msg

#
# Configuration File Handling.
#

class ConfigurationFile(object):
    """Write a file, tracking old and new versions.

    Supports writing a new version of a file and applying and
    reverting those changes.
    """

    __STATE = {"OPEN":"OPEN",
               "NOT-APPLIED":"NOT-APPLIED", "APPLIED":"APPLIED",
               "REVERTED":"REVERTED", "COMMITTED": "COMMITTED"}

    def __init__(self, path):
        dirname,basename = os.path.split(path)

        self.__state = self.__STATE['OPEN']
        self.__children = []

        self.__path    = os.path.join(dirname, basename)
        self.__oldpath = os.path.join(dirname, "." + basename + ".xapi-old")
        self.__newpath = os.path.join(dirname, "." + basename + ".xapi-new")

        self.__f = open(self.__newpath, "w")

    def attach_child(self, child):
        self.__children.append(child)

    def path(self):
        return self.__path

    def readlines(self):
        try:
            return open(self.path()).readlines()
        except:
            return ""

    def write(self, args):
        if self.__state != self.__STATE['OPEN']:
            raise Error("Attempt to write to file in state %s" % self.__state)
        self.__f.write(args)

    def close(self):
        if self.__state != self.__STATE['OPEN']:
            raise Error("Attempt to close file in state %s" % self.__state)

        self.__f.close()
        self.__state = self.__STATE['NOT-APPLIED']

    def changed(self):
        if self.__state != self.__STATE['NOT-APPLIED']:
            raise Error("Attempt to compare file in state %s" % self.__state)

        return True

    def apply(self):
        if self.__state != self.__STATE['NOT-APPLIED']:
            raise Error("Attempt to apply configuration from state %s" % self.__state)

        for child in self.__children:
            child.apply()

        log("Applying changes to %s configuration" % self.__path)

        # Remove previous backup.
        if os.access(self.__oldpath, os.F_OK):
            os.unlink(self.__oldpath)

        # Save current configuration.
        if os.access(self.__path, os.F_OK):
            os.link(self.__path, self.__oldpath)
            os.unlink(self.__path)

        # Apply new configuration.
        assert(os.path.exists(self.__newpath))
        os.link(self.__newpath, self.__path)

        # Remove temporary file.
        os.unlink(self.__newpath)

        self.__state = self.__STATE['APPLIED']

    def revert(self):
        if self.__state != self.__STATE['APPLIED']:
            raise Error("Attempt to revert configuration from state %s" % self.__state)

        for child in self.__children:
            child.revert()

        log("Reverting changes to %s configuration" % self.__path)

        # Remove existing new configuration
        if os.access(self.__newpath, os.F_OK):
            os.unlink(self.__newpath)

        # Revert new configuration.
        if os.access(self.__path, os.F_OK):
            os.link(self.__path, self.__newpath)
            os.unlink(self.__path)

        # Revert to old configuration.
        if os.access(self.__oldpath, os.F_OK):
            os.link(self.__oldpath, self.__path)
            os.unlink(self.__oldpath)

        # Leave .*.xapi-new as an aid to debugging.

        self.__state = self.__STATE['REVERTED']

    def commit(self):
        if self.__state != self.__STATE['APPLIED']:
            raise Error("Attempt to commit configuration from state %s" % self.__state)

        for child in self.__children:
            child.commit()

        log("Committing changes to %s configuration" % self.__path)

        if os.access(self.__oldpath, os.F_OK):
            os.unlink(self.__oldpath)
        if os.access(self.__newpath, os.F_OK):
            os.unlink(self.__newpath)

        self.__state = self.__STATE['COMMITTED']

def interface_up(i):
    operstate = os.path.join("/sys/class/net",i,"operstate")
    if not os.path.exists(operstate):
        log("No operstate for interface %s, assuming down" % i)
        return 0

    f = open(operstate)
    state = f.read().strip()
    f.close()

    # bridges confusingly return "unknown" when they are up
    return state in ["up", "unknown"]

def ifdown(interface):
    if not netdev_exists(interface):
        log("ifdown: interface %s does not exist, ignoring" % interface)
        return
    run_command(["/sbin/ifdown", interface])

def ifup(interface):
    run_command(["/sbin/ifup", interface])


def delbr(bridge):
    if not netdev_exists(bridge):
        log("delbr: bridge %s does not exist, ignoring" % bridge)
        return
    run_command(["/usr/sbin/brctl", "delbr", bridge])

def vconfig_rem(vlan):
    if not netdev_exists(vlan):
        log("vconfig del: vlan %s does not exist, ignoring" % vlan)
        return
    run_command(["/sbin/vconfig", "rem", vlan])

def configure_ethtool(oc, f):
    # Options for "ethtool -s"
    settings = None
    setting_opts = ["autoneg", "speed", "duplex"]
    # Options for "ethtool -K"
    offload = None
    offload_opts = ["rx", "tx", "sg", "tso", "ufo", "gso"]

    for opt in [opt for opt in setting_opts + offload_opts if oc.has_key("ethtool-" + opt)]:
        val = oc["ethtool-" + opt]

        if opt in ["speed"]:
            if val in ["10", "100", "1000"]:
                val = "speed " + val
            else:
                log("Invalid value for ethtool-speed = %s. Must be 10|100|1000." % val)
                val = None
        elif opt in ["duplex"]:
            if val in ["half", "full"]:
                val = "duplex " + val
            else:
                log("Invalid value for ethtool-duplex = %s. Must be half|full." % val)
                val = None
        elif opt in ["autoneg"] + offload_opts:
            if val in ["true", "on"]:
                val = opt + " on"
            elif val in ["false", "off"]:
                val = opt + " off"
            else:
                log("Invalid value for ethtool-%s = %s. Must be on|true|off|false." % (opt, val))
                val = None

        if opt in setting_opts:
            if val and settings:
                settings = settings + " " + val
            else:
                settings = val
        elif opt in offload_opts:
            if val and offload:
                offload = offload + " " + val
            else:
                offload = val

    if settings:
        f.write("ETHTOOL_OPTS=\"%s\"\n" % settings)
    if offload:
        f.write("ETHTOOL_OFFLOAD_OPTS=\"%s\"\n" % offload)

def configure_mtu(oc, f):
    if not oc.has_key('mtu'):
        return

    try:
        mtu = int(oc['mtu'])
        f.write("MTU=%d\n" % mtu)
    except ValueError, x:
        log("Invalid value for mtu = %s" % mtu)

def open_pif_ifcfg(pif):
    pifrec = db.get_pif_record(pif)

    interface = pif_netdev_name(pif)
    log("Configuring %s (%s)" % (interface, pifrec['MAC']))

    f = ConfigurationFile("/etc/sysconfig/network-scripts/ifcfg-%s" % interface)

    f.write("# DO NOT EDIT: This file (%s) was autogenerated by %s\n" % \
            (os.path.basename(f.path()), os.path.basename(sys.argv[0])))
    f.write("XEMANAGED=yes\n")
    f.write("DEVICE=%s\n" % interface)
    f.write("ONBOOT=no\n")

    if pifrec.has_key('other_config'):
        configure_ethtool(pifrec['other_config'], f)
        configure_mtu(pifrec['other_config'], f)

    return f

#
# Helper functions for encoding/decoding database attributes to/from XML.
#

def str_to_xml(xml, parent, tag, val):
    e = xml.createElement(tag)
    parent.appendChild(e)
    v = xml.createTextNode(val)
    e.appendChild(v)
def str_from_xml(n):
    def getText(nodelist):
        rc = ""
        for node in nodelist:
            if node.nodeType == node.TEXT_NODE:
                rc = rc + node.data
        return rc
    return getText(n.childNodes).strip()

def bool_to_xml(xml, parent, tag, val):
    if val:
        str_to_xml(xml, parent, tag, "True")
    else:
        str_to_xml(xml, parent, tag, "False")
def bool_from_xml(n):
    s = str_from_xml(n)
    if s == "True":
        return True
    elif s == "False":
        return False
    else:
        raise Error("Unknown boolean value %s" % s)

def strlist_to_xml(xml, parent, ltag, itag, val):
    e = xml.createElement(ltag)
    parent.appendChild(e)
    for v in val:
        c = xml.createElement(itag)
        e.appendChild(c)
        cv = xml.createTextNode(v)
        c.appendChild(cv)
def strlist_from_xml(n, ltag, itag):
    ret = []
    for n in n.childNodes:
        if n.nodeName == itag:
            ret.append(str_from_xml(n))
    return ret

def otherconfig_to_xml(xml, parent, val, attrs):
    otherconfig = xml.createElement("other_config")
    parent.appendChild(otherconfig)
    for n,v in val.items():
        if not n in attrs:
            raise Error("Unknown other-config attribute: %s" % n)
        str_to_xml(xml, otherconfig, n, v)
def otherconfig_from_xml(n, attrs):
    ret = {}
    for n in n.childNodes:
        if n.nodeName in attrs:
            ret[n.nodeName] = str_from_xml(n)
    return ret

#
# Definitions of the database objects (and their attributes) used by interface-reconfigure.
#
# Each object is defined by a dictionary mapping an attribute name in
# the xapi database to a tuple containing two items:
#  - a function which takes this attribute and encodes it as XML.
#  - a function which takes XML and decocdes it into a value.
#
# other-config attributes are specified as a simple array of strings

PIF_XML_TAG = "pif"
VLAN_XML_TAG = "vlan"
BOND_XML_TAG = "bond"
NETWORK_XML_TAG = "network"

ETHTOOL_OTHERCONFIG_ATTRS = ['ethtool-%s' % x for x in 'autoneg', 'speed', 'duplex', 'rx', 'tx', 'sg', 'tso', 'ufo', 'gso' ]

PIF_OTHERCONFIG_ATTRS = [ 'domain', 'peerdns', 'defaultroute', 'mtu', 'static-routes' ] + \
                        [ 'bond-%s' % x for x in 'mode', 'miimon', 'downdelay', 'updelay', 'use_carrier' ] + \
                        ETHTOOL_OTHERCONFIG_ATTRS

PIF_ATTRS = { 'uuid': (str_to_xml,str_from_xml),
              'management': (bool_to_xml,bool_from_xml),
              'network': (str_to_xml,str_from_xml),
              'device': (str_to_xml,str_from_xml),
              'bond_master_of': (lambda x, p, t, v: strlist_to_xml(x, p, 'bond_master_of', 'slave', v),
                                 lambda n: strlist_from_xml(n, 'bond_master_of', 'slave')),
              'bond_slave_of': (str_to_xml,str_from_xml),
              'VLAN': (str_to_xml,str_from_xml),
              'VLAN_master_of': (str_to_xml,str_from_xml),
              'VLAN_slave_of': (lambda x, p, t, v: strlist_to_xml(x, p, 'VLAN_slave_of', 'master', v),
                                lambda n: strlist_from_xml(n, 'VLAN_slave_Of', 'master')),
              'ip_configuration_mode': (str_to_xml,str_from_xml),
              'IP': (str_to_xml,str_from_xml),
              'netmask': (str_to_xml,str_from_xml),
              'gateway': (str_to_xml,str_from_xml),
              'DNS': (str_to_xml,str_from_xml),
              'MAC': (str_to_xml,str_from_xml),
              'other_config': (lambda x, p, t, v: otherconfig_to_xml(x, p, v, PIF_OTHERCONFIG_ATTRS),
                               lambda n: otherconfig_from_xml(n, PIF_OTHERCONFIG_ATTRS)),

              # Special case: We write the current value
              # PIF.currently-attached to the cache but since it will
              # not be valid when we come to use the cache later
              # (i.e. after a reboot) we always read it as False.
              'currently_attached': (bool_to_xml, lambda n: False),
            }

VLAN_ATTRS = { 'uuid': (str_to_xml,str_from_xml),
               'tagged_PIF': (str_to_xml,str_from_xml),
               'untagged_PIF': (str_to_xml,str_from_xml),
             }

BOND_ATTRS = { 'uuid': (str_to_xml,str_from_xml),
               'master': (str_to_xml,str_from_xml),
               'slaves': (lambda x, p, t, v: strlist_to_xml(x, p, 'slaves', 'slave', v),
                          lambda n: strlist_from_xml(n, 'slaves', 'slave')),
             }

NETWORK_OTHERCONFIG_ATTRS = [ 'mtu', 'static-routes' ] + ETHTOOL_OTHERCONFIG_ATTRS

NETWORK_ATTRS = { 'uuid': (str_to_xml,str_from_xml),
                  'bridge': (str_to_xml,str_from_xml),
                  'PIFs': (lambda x, p, t, v: strlist_to_xml(x, p, 'PIFs', 'PIF', v),
                           lambda n: strlist_from_xml(n, 'PIFs', 'PIF')),
                  'other_config': (lambda x, p, t, v: otherconfig_to_xml(x, p, v, NETWORK_OTHERCONFIG_ATTRS),
                                   lambda n: otherconfig_from_xml(n, NETWORK_OTHERCONFIG_ATTRS)),
                }

#
# Database Cache object
#

class DatabaseCache(object):
    def __read_xensource_inventory(self):
        filename = "/etc/xensource-inventory"
        f = open(filename, "r")
        lines = [x.strip("\n") for x in f.readlines()]
        f.close()

        defs = [ (l[:l.find("=")], l[(l.find("=") + 1):]) for l in lines ]
        defs = [ (a, b.strip("'")) for (a,b) in defs ]

        return dict(defs)
    def __pif_on_host(self,pif):
        return self.__pifs.has_key(pif)

    def __get_pif_records_from_xapi(self, session, host):
        self.__pifs = {}
        for (p,rec) in session.xenapi.PIF.get_all_records().items():
            if rec['host'] != host:
                continue
            self.__pifs[p] = {}
            for f in PIF_ATTRS:
                self.__pifs[p][f] = rec[f]
            self.__pifs[p]['other_config'] = {}
            for f in PIF_OTHERCONFIG_ATTRS:
                if not rec['other_config'].has_key(f): continue
                self.__pifs[p]['other_config'][f] = rec['other_config'][f]

    def __get_vlan_records_from_xapi(self, session):
        self.__vlans = {}
        for v in session.xenapi.VLAN.get_all():
            rec = session.xenapi.VLAN.get_record(v)
            if not self.__pif_on_host(rec['untagged_PIF']):
                continue
            self.__vlans[v] = {}
            for f in VLAN_ATTRS:
                self.__vlans[v][f] = rec[f]

    def __get_bond_records_from_xapi(self, session):
        self.__bonds = {}
        for b in session.xenapi.Bond.get_all():
            rec = session.xenapi.Bond.get_record(b)
            if not self.__pif_on_host(rec['master']):
                continue
            self.__bonds[b] = {}
            for f in BOND_ATTRS:
                self.__bonds[b][f] = rec[f]

    def __get_network_records_from_xapi(self, session):
        self.__networks = {}
        for n in session.xenapi.network.get_all():
            rec = session.xenapi.network.get_record(n)
            self.__networks[n] = {}
            for f in NETWORK_ATTRS:
                if f == "PIFs":
                    # drop PIFs on other hosts
                    self.__networks[n][f] = [p for p in rec[f] if self.__pif_on_host(p)]
                else:
                    self.__networks[n][f] = rec[f]
            self.__networks[n]['other_config'] = {}
            for f in NETWORK_OTHERCONFIG_ATTRS:
                if not rec['other_config'].has_key(f): continue
                self.__networks[n]['other_config'][f] = rec['other_config'][f]

    def __to_xml(self, xml, parent, key, ref, rec, attrs):
        """Encode a database object as XML"""
        e = xml.createElement(key)
        parent.appendChild(e)
        if ref:
            e.setAttribute('ref', ref)

        for n,v in rec.items():
            if attrs.has_key(n):
                h,_ = attrs[n]
                h(xml, e, n, v)
            else:
                raise Error("Unknown attribute %s" % n)
    def __from_xml(self, e, attrs):
        """Decode a database object from XML"""
        ref = e.attributes['ref'].value
        rec = {}
        for n in e.childNodes:
            if n.nodeName in attrs:
                _,h = attrs[n.nodeName]
                rec[n.nodeName] = h(n)
        return (ref,rec)

    def __init__(self, session_ref=None, cache_file=None):
        if session_ref and cache_file:
            raise Error("can't specify session reference and cache file")
        if cache_file == None:
            session = XenAPI.xapi_local()

            if not session_ref:
                log("No session ref given on command line, logging in.")
                session.xenapi.login_with_password("root", "")
            else:
                session._session = session_ref

            try:

                inventory = self.__read_xensource_inventory()
                assert(inventory.has_key('INSTALLATION_UUID'))
                log("host uuid is %s" % inventory['INSTALLATION_UUID'])

                host = session.xenapi.host.get_by_uuid(inventory['INSTALLATION_UUID'])

                self.__get_pif_records_from_xapi(session, host)

                self.__get_vlan_records_from_xapi(session)
                self.__get_bond_records_from_xapi(session)
                self.__get_network_records_from_xapi(session)
            finally:
                if not session_ref:
                    session.xenapi.session.logout()
        else:
            log("Loading xapi database cache from %s" % cache_file)

            xml = parseXML(cache_file)

            self.__pifs = {}
            self.__bonds = {}
            self.__vlans = {}
            self.__networks = {}

            assert(len(xml.childNodes) == 1)
            toplevel = xml.childNodes[0]

            assert(toplevel.nodeName == "xenserver-network-configuration")

            for n in toplevel.childNodes:
                if n.nodeName == "#text":
                    pass
                elif n.nodeName == PIF_XML_TAG:
                    (ref,rec) = self.__from_xml(n, PIF_ATTRS)
                    self.__pifs[ref] = rec
                elif n.nodeName == BOND_XML_TAG:
                    (ref,rec) = self.__from_xml(n, BOND_ATTRS)
                    self.__bonds[ref] = rec
                elif n.nodeName == VLAN_XML_TAG:
                    (ref,rec) = self.__from_xml(n, VLAN_ATTRS)
                    self.__vlans[ref] = rec
                elif n.nodeName == NETWORK_XML_TAG:
                    (ref,rec) = self.__from_xml(n, NETWORK_ATTRS)
                    self.__networks[ref] = rec
                else:
                    raise Error("Unknown XML element %s" % n.nodeName)

    def save(self, cache_file):

        xml = getDOMImplementation().createDocument(
            None, "xenserver-network-configuration", None)
        for (ref,rec) in self.__pifs.items():
            self.__to_xml(xml, xml.documentElement, PIF_XML_TAG, ref, rec, PIF_ATTRS)
        for (ref,rec) in self.__bonds.items():
            self.__to_xml(xml, xml.documentElement, BOND_XML_TAG, ref, rec, BOND_ATTRS)
        for (ref,rec) in self.__vlans.items():
            self.__to_xml(xml, xml.documentElement, VLAN_XML_TAG, ref, rec, VLAN_ATTRS)
        for (ref,rec) in self.__networks.items():
            self.__to_xml(xml, xml.documentElement, NETWORK_XML_TAG, ref, rec,
                          NETWORK_ATTRS)

        f = open(cache_file, 'w')
        f.write(xml.toprettyxml())
        f.close()

    def get_pif_by_uuid(self, uuid):
        pifs = map(lambda (ref,rec): ref,
                  filter(lambda (ref,rec): uuid == rec['uuid'],
                         self.__pifs.items()))
        if len(pifs) == 0:
            raise Error("Unknown PIF \"%s\"" % uuid)
        elif len(pifs) > 1:
            raise Error("Non-unique PIF \"%s\"" % uuid)

        return pifs[0]

    def get_pifs_by_device(self, device):
        return map(lambda (ref,rec): ref,
                   filter(lambda (ref,rec): rec['device'] == device,
                          self.__pifs.items()))

    def get_pif_by_bridge(self, bridge):
        networks = map(lambda (ref,rec): ref,
                       filter(lambda (ref,rec): rec['bridge'] == bridge,
                              self.__networks.items()))
        if len(networks) == 0:
            raise Error("No matching network \"%s\"" % bridge)

        answer = None
        for network in networks:
            nwrec = self.get_network_record(network)
            for pif in nwrec['PIFs']:
                pifrec = self.get_pif_record(pif)
                if answer:
                    raise Error("Multiple PIFs on host for network %s" % (bridge))
                answer = pif
        if not answer:
            raise Error("No PIF on host for network %s" % (bridge))
        return answer

    def get_pif_record(self, pif):
        if self.__pifs.has_key(pif):
            return self.__pifs[pif]
        raise Error("Unknown PIF \"%s\"" % pif)
    def get_all_pifs(self):
        return self.__pifs
    def pif_exists(self, pif):
        return self.__pifs.has_key(pif)

    def get_management_pif(self):
        """ Returns the management pif on host
        """
        all = self.get_all_pifs()
        for pif in all:
            pifrec = self.get_pif_record(pif)
            if pifrec['management']: return pif
        return None

    def get_network_record(self, network):
        if self.__networks.has_key(network):
            return self.__networks[network]
        raise Error("Unknown network \"%s\"" % network)

    def get_bond_record(self, bond):
        if self.__bonds.has_key(bond):
            return self.__bonds[bond]
        else:
            return None

    def get_vlan_record(self, vlan):
        if self.__vlans.has_key(vlan):
            return self.__vlans[vlan]
        else:
            return None

#
# Boot from Network filesystem or device.
#

def check_allowed(pif):
    """Determine whether interface-reconfigure should be manipulating this PIF.

    Used to prevent system PIFs (such as network root disk) from being interfered with.
    """

    pifrec = db.get_pif_record(pif)
    try:
        f = open("/proc/ardence")
        macline = filter(lambda x: x.startswith("HWaddr:"), f.readlines())
        f.close()
        if len(macline) == 1:
            p = re.compile(".*\s%(MAC)s\s.*" % pifrec, re.IGNORECASE)
            if p.match(macline[0]):
                log("Skipping PVS device %(device)s (%(MAC)s)" % pifrec)
                return False
    except IOError:
        pass
    return True

#
# Bare Network Devices -- network devices without IP configuration
#

def netdev_exists(netdev):
    return os.path.exists("/sys/class/net/" + netdev)

def pif_netdev_name(pif):
    """Get the netdev name for a PIF."""

    pifrec = db.get_pif_record(pif)

    if pif_is_vlan(pif):
        return "%(device)s.%(VLAN)s" % pifrec
    else:
        return pifrec['device']

#
# IP Network Devices -- network devices with IP configuration
#

def pif_ipdev_name(pif):
    """Return the ipdev name associated with pif"""
    pifrec = db.get_pif_record(pif)
    nwrec = db.get_network_record(pifrec['network'])

    if nwrec['bridge']:
        # TODO: sanity check that nwrec['bridgeless'] != 'true'
        return nwrec['bridge']
    else:
        # TODO: sanity check that nwrec['bridgeless'] == 'true'
        return pif_netdev_name(pif)

#
# Bridges
#

def bridge_name(pif):
    """Return the bridge name associated with pif, or None if network is bridgeless"""
    pifrec = db.get_pif_record(pif)
    nwrec = db.get_network_record(pifrec['network'])

    if nwrec['bridge']:
        # TODO: sanity check that nwrec['bridgeless'] != 'true'
        return nwrec['bridge']
    else:
        # TODO: sanity check that nwrec['bridgeless'] == 'true'
        return None

def load_bonding_driver():
    log("Loading bonding driver")
    run_command(["/sbin/modprobe", "bonding"])
    try:
        # bond_device_exists() uses the contents of sysfs_bonding_masters to work out which devices
        # have already been created.  Unfortunately the driver creates "bond0" automatically at
        # modprobe init.  Get rid of this now or our accounting will go wrong.
        f = open(sysfs_bonding_masters, "w")
        f.write("-bond0")
        f.close()
    except IOError, e:
        log("Failed to load bonding driver: %s" % e)

def bonding_driver_loaded():
    lines = open("/proc/modules").read().split("\n")
    modules = [line.split(" ")[0] for line in lines]
    return "bonding" in modules

def bond_device_exists(name):
    f = open(sysfs_bonding_masters, "r")
    bonds = f.readline().split()
    f.close()
    return name in bonds

def __create_bond_device(name):

    if not bonding_driver_loaded():
        load_bonding_driver()

    if bond_device_exists(name):
        log("bond master %s already exists, not creating" % name)
    else:
        log("Creating bond master %s" % name)
        try:
            f = open(sysfs_bonding_masters, "w")
            f.write("+" + name)
            f.close()
        except IOError, e:
            log("Failed to create %s: %s" % (name, e))

def create_bond_device(pif):
    """Ensures that a bond master device exists in the kernel."""

    pifrec = db.get_pif_record(pif)

    if len(pifrec['bond_master_of']) == 0:
        return

    __create_bond_device(pif_netdev_name(pif))

def __destroy_bond_device(name):
    if bond_device_exists(name):
        retries = 10 # 10 * 0.5 seconds
        while retries > 0:
            retries = retries - 1
            log("Destroying bond master %s (%d attempts remain)" % (name,retries))
            try:
                f = open(sysfs_bonding_masters, "w")
                f.write("-" + name)
                f.close()
                retries = 0
            except IOError, e:
                time.sleep(0.5)
    else:
        log("bond master %s does not exist, not destroying" % name)

def destroy_bond_device(pif):
    """No, Mr. Bond, I expect you to die."""

    pifrec = db.get_pif_record(pif)

    if len(pifrec['bond_master_of']) == 0:
        return

    # If the bonding module isn't loaded then do nothing.
    if not os.access(sysfs_bonding_masters, os.F_OK):
        return

    name = pif_netdev_name(pif)

    __destroy_bond_device(name)

def configure_physical_interface(pif):
    """Write the configuration for a physical interface.

    Writes the configuration file for the physical interface described by
    the pif object.

    Returns the open file handle for the interface configuration file.
    """

    pifrec = db.get_pif_record(pif)

    f = open_pif_ifcfg(pif)

    f.write("TYPE=Ethernet\n")
    f.write("HWADDR=%(MAC)s\n" % pifrec)

    return f

def get_bond_masters_of_pif(pif):
    """Returns a list of PIFs which are bond masters of this PIF"""

    pifrec = db.get_pif_record(pif)

    bso = pifrec['bond_slave_of']

    # bond-slave-of is currently a single reference but in principle a
    # PIF could be a member of several bonds which are not
    # concurrently attached. Be robust to this possibility.
    if not bso or bso == "OpaqueRef:NULL":
        bso = []
    elif not type(bso) == list:
        bso = [bso]

    bondrecs = [db.get_bond_record(bond) for bond in bso]
    bondrecs = [rec for rec in bondrecs if rec]

    return [bond['master'] for bond in bondrecs]

def get_bond_slaves_of_pif(pif):
    """Returns a list of PIFs which make up the given bonded pif."""

    pifrec = db.get_pif_record(pif)

    bmo = pifrec['bond_master_of']
    if len(bmo) > 1:
        raise Error("Bond-master-of contains too many elements")

    if len(bmo) == 0:
        return []

    bondrec = db.get_bond_record(bmo[0])
    if not bondrec:
        raise Error("No bond record for bond master PIF")

    # build a list of slave's pifs
    slave_pifs = bondrec['slaves']

    # Ensure any currently attached slaves are listed in the opposite order to the order in
    # which they were attached.  The first slave attached must be the last detached since
    # the bond is using its MAC address.
    try:
        attached_slaves = open("/sys/class/net/%s/bonding/slaves" % pifrec['device']).readline().split()
        for slave in attached_slaves:
            pifs = [p for p in db.get_pifs_by_device(slave) if not pif_is_vlan(p)]
            slave_pif = pifs[0]
            slave_pifs.remove(slave_pif)
            slave_pifs.insert(0, slave_pif)
    except IOError:
        pass

    return slave_pifs

def configure_bond_interface(pif):
    """Write the configuration for a bond interface.

    Writes the configuration file for the bond interface described by
    the pif object. Handles writing the configuration for the slave
    interfaces.

    Returns the open file handle for the bond interface configuration
    file.
    """

    pifrec = db.get_pif_record(pif)
    oc = pifrec['other_config']
    f = open_pif_ifcfg(pif)

    if pifrec['MAC'] != "":
        f.write("MACADDR=%s\n" % pifrec['MAC'])

    for slave in get_bond_slaves_of_pif(pif):
        s = configure_physical_interface(slave)
        s.write("MASTER=%(device)s\n" % pifrec)
        s.write("SLAVE=yes\n")
        s.close()
        f.attach_child(s)

    # The bond option defaults
    bond_options = {
        "mode":   "balance-slb",
        "miimon": "100",
        "downdelay": "200",
        "updelay": "31000",
        "use_carrier": "1",
        }

    # override defaults with values from other-config whose keys being with "bond-"
    overrides = filter(lambda (key,val): key.startswith("bond-"), oc.items())
    overrides = map(lambda (key,val): (key[5:], val), overrides)
    bond_options.update(overrides)

    # write the bond options to ifcfg-bondX
    f.write('BONDING_OPTS="')
    for (name,val) in bond_options.items():
        f.write("%s=%s " % (name,val))
    f.write('"\n')
    return f

def pif_is_vlan(pif):
    return db.get_pif_record(pif)['VLAN'] != '-1'

def get_vlan_slave_of_pif(pif):
    """Find the PIF which is the VLAN slave of pif.

Returns the 'physical' PIF underneath the a VLAN PIF @pif."""

    pifrec = db.get_pif_record(pif)

    vlan = pifrec['VLAN_master_of']
    if not vlan or vlan == "OpaqueRef:NULL":
        raise Error("PIF is not a VLAN master")

    vlanrec = db.get_vlan_record(vlan)
    if not vlanrec:
        raise Error("No VLAN record found for PIF")

    return vlanrec['tagged_PIF']

def get_vlan_masters_of_pif(pif):
    """Returns a list of PIFs which are VLANs on top of the given pif."""

    pifrec = db.get_pif_record(pif)
    vlans = [db.get_vlan_record(v) for v in pifrec['VLAN_slave_of']]
    return [v['untagged_PIF'] for v in vlans if v and db.pif_exists(v['untagged_PIF'])]

def configure_vlan_interface(pif):
    """Write the configuration for a VLAN interface.

    Writes the configuration file for the VLAN interface described by
    the pif object. Handles writing the configuration for the master
    interface if necessary.

    Returns the open file handle for the VLAN interface configuration
    file.
    """

    slave = configure_pif(get_vlan_slave_of_pif(pif))

    f = open_pif_ifcfg(pif)
    f.write("VLAN=yes\n")
    f.attach_child(slave)

    return f

def configure_pif(pif):
    """Write the configuration for a PIF object.

    Writes the configuration file the PIF and all dependent
    interfaces (bond slaves and VLAN masters etc).

    Returns the open file handle for the interface configuration file.
    """

    pifrec = db.get_pif_record(pif)

    if pif_is_vlan(pif):
        f = configure_vlan_interface(pif)
    elif len(pifrec['bond_master_of']) != 0:
        f = configure_bond_interface(pif)
    else:
        f = configure_physical_interface(pif)

    bridge = bridge_name(pif)
    if bridge:
        f.write("BRIDGE=%s\n" % bridge)

    f.close()

    return f

def bring_down_bridge(bridge, destroy=False):
    """Bring down the bridge associated with a PIF."""
    log("Bring bridge %s down" % bridge)
    ifdown(bridge)
    if destroy:
        log("Destroy bridge %s" % bridge)
        delbr(bridge)

def bring_up_bridge(bridge):
    """Bring up the bridge associated with a PIF."""
    log("Bring bridge %s up" % bridge)
    ifup(bridge)

def bring_down_interface(pif, destroy=False):
    """Bring down the interface associated with PIF.

    Brings down the given interface as well as any physical interfaces
    which are bond slaves of this one. This is because they will be
    required when the bond is brought up."""

    if pif_is_vlan(pif):
        interface = pif_netdev_name(pif)
        log("bring_down_interface: %s is a VLAN" % interface)
        ifdown(interface)

        if destroy:
            log("Destroy vlan device %s" % interface)
            vconfig_rem(interface)
            bridge = bridge_name(pif)
            if bridge:
                bring_down_bridge(bridge, destroy=True)
        else:
            return

        slave = get_vlan_slave_of_pif(pif)
        if db.get_pif_record(slave)['currently_attached']:
            log("bring_down_interface: vlan slave is currently attached")
            return

        masters = get_vlan_masters_of_pif(slave)
        masters = [m for m in masters if m != pif and db.get_pif_record(m)['currently_attached']]
        if len(masters) > 0:
            log("bring_down_interface: vlan slave has other masters")
            return

        log("bring_down_interface: no more masters, bring down vlan slave %s" % pif_netdev_name(slave))
        pif = slave
    else:
        vlan_masters = get_vlan_masters_of_pif(pif)
        log("vlan masters of %s - %s" % (db.get_pif_record(pif)['device'], [pif_netdev_name(m) for m in vlan_masters]))
        if len([m for m in vlan_masters if db.get_pif_record(m)['currently_attached']]) > 0:
            log("Leaving %s up due to currently attached VLAN masters" % pif_netdev_name(pif))
            return

    # pif is now either a bond or a physical device which needs to be brought down

    # Need to bring down bond slaves first since the bond device
    # must be up to enslave/unenslave.
    bond_slaves = get_bond_slaves_of_pif(pif)
    log("bond slaves of %s - %s" % (db.get_pif_record(pif)['device'], [pif_netdev_name(s) for s in bond_slaves]))
    for slave in bond_slaves:
        slave_interface = pif_netdev_name(slave)
        slave_bridge = bridge_name(slave)
        if db.get_pif_record(slave)['currently_attached']:
            log("leave bond slave %s up (currently attached)" % slave_interface)
            continue
        log("bring down bond slave %s" % slave_interface)
        ifdown(slave_interface)
        # Also destroy the bridge associated with the slave, since
        # it will carry the MAC address and possibly an IP address
        # leading to confusion.
        if slave_bridge:
            bring_down_bridge(slave_bridge, destroy=True)

    interface = pif_netdev_name(pif)
    log("Bring interface %s down" % interface)
    ifdown(interface)

    if destroy:
        destroy_bond_device(pif)
        bridge = bridge_name(pif)
        if bridge:
            bring_down_bridge(bridge, destroy=True)

def interface_is_up(pif):
    try:
        interface = pif_netdev_name(pif)
        state = open("/sys/class/net/%s/operstate" % interface).read().strip()
        return state == "up"
    except:
        return False # interface prolly doesn't exist

def bring_up_interface(pif):
    """Bring up the interface associated with a PIF.

    Also bring up the interfaces listed in additional.
    """

    # VLAN on bond seems to need bond brought up explicitly, but VLAN
    # on normal device does not. Might as well always bring it up.
    if pif_is_vlan(pif):
        slave = get_vlan_slave_of_pif(pif)
        if not interface_is_up(slave):
            bring_up_interface(slave)

    interface = pif_netdev_name(pif)

    create_bond_device(pif)

    log("Bring interface %s up" % interface)
    ifup(interface)

#
# IP device configuration
#

def ipdev_configure_static_routes(interface, oc, f):
    """Open a route-<interface> file for static routes.

    Opens the static routes configuration file for interface and writes one
    line for each route specified in the network's other config "static-routes" value.
    E.g. if
           interface ( RO): xenbr1
           other-config (MRW): static-routes: 172.16.0.0/15/192.168.0.3,172.18.0.0/16/192.168.0.4;...

    Then route-xenbr1 should be
          172.16.0.0/15 via 192.168.0.3 dev xenbr1
          172.18.0.0/16 via 192.168.0.4 dev xenbr1
    """
    if oc.has_key('static-routes'):
        # The key is present - extract comma seperates entries
        lines = oc['static-routes'].split(',')
    else:
        # The key is not present, i.e. there are no static routes
        lines = []

    child = ConfigurationFile("/etc/sysconfig/network-scripts/route-%s" % interface)
    child.write("# DO NOT EDIT: This file (%s) was autogenerated by %s\n" % \
            (os.path.basename(child.path()), os.path.basename(sys.argv[0])))

    try:
        for l in lines:
            network, masklen, gateway = l.split('/')
            child.write("%s/%s via %s dev %s\n" % (network, masklen, gateway, interface))

        f.attach_child(child)
        child.close()

    except ValueError, e:
        log("Error in other-config['static-routes'] format for network %s: %s" % (interface, e))

def ipdev_open_ifcfg(pif):
    ipdev = pif_ipdev_name(pif)

    log("Writing network configuration for %s" % ipdev)

    f = ConfigurationFile("/etc/sysconfig/network-scripts/ifcfg-%s" % ipdev)

    f.write("# DO NOT EDIT: This file (%s) was autogenerated by %s\n" % \
            (os.path.basename(f.path()), os.path.basename(sys.argv[0])))
    f.write("XEMANAGED=yes\n")
    f.write("DEVICE=%s\n" % ipdev)
    f.write("ONBOOT=no\n")

    return f

def ipdev_configure_network(pif):
    """Write the configuration file for a network.

    Writes configuration derived from the network object into the relevant
    ifcfg file.  The configuration file is passed in, but if the network is
    bridgeless it will be ifcfg-<interface>, otherwise it will be ifcfg-<bridge>.

    This routine may also write ifcfg files of the networks corresponding to other PIFs
    in order to maintain consistency.

    params:
        pif:  Opaque_ref of pif
    """

    pifrec = db.get_pif_record(pif)
    nwrec = db.get_network_record(pifrec['network'])

    ipdev = pif_ipdev_name(pif)

    f = ipdev_open_ifcfg(pif)

    mode = pifrec['ip_configuration_mode']
    log("Configuring %s using %s configuration" % (ipdev, mode))

    oc = None
    if pifrec.has_key('other_config'):
        oc = pifrec['other_config']

    if ipdev != pif_netdev_name(pif):
        f.write("TYPE=Bridge\n")
        f.write("DELAY=0\n")
        f.write("STP=off\n")
        f.write("PIFDEV=%s\n" % pif_netdev_name(pif))
    else:
        f.write("TYPE=Ethernet\n")

    if pifrec['ip_configuration_mode'] == "DHCP":
        f.write("BOOTPROTO=dhcp\n")
        f.write("PERSISTENT_DHCLIENT=yes\n")
    elif pifrec['ip_configuration_mode'] == "Static":
        f.write("BOOTPROTO=none\n")
        f.write("NETMASK=%(netmask)s\n" % pifrec)
        f.write("IPADDR=%(IP)s\n" % pifrec)
        f.write("GATEWAY=%(gateway)s\n" % pifrec)
    elif pifrec['ip_configuration_mode'] == "None":
        f.write("BOOTPROTO=none\n")
    else:
        raise Error("Unknown ip-configuration-mode %s" % pifrec['ip_configuration_mode'])

    if nwrec.has_key('other_config'):
        configure_ethtool(nwrec['other_config'], f)
        configure_mtu(nwrec['other_config'], f)

        ipdev_configure_static_routes(ipdev, nwrec['other_config'], f)

    if pifrec.has_key('DNS') and pifrec['DNS'] != "":
        ServerList = pifrec['DNS'].split(",")
        for i in range(len(ServerList)): f.write("DNS%d=%s\n" % (i+1, ServerList[i]))
    if oc and oc.has_key('domain'):
        f.write("DOMAIN='%s'\n" % oc['domain'].replace(',', ' '))

    # There can be only one DNSDEV and one GATEWAYDEV in /etc/sysconfig/network.
    #
    # The peerdns pif will be the one with
    # pif::other-config:peerdns=true, or the mgmt pif if none have
    # this set.
    #
    # The gateway pif will be the one with
    # pif::other-config:defaultroute=true, or the mgmt pif if none
    # have this set.

    # Work out which pif on this host should be the DNSDEV and which
    # should be the GATEWAYDEV
    #
    # Note: we prune out the bond master pif (if it exists). This is
    # because when we are called to bring up an interface with a bond
    # master, it is implicit that we should bring down that master.

    pifs_on_host = [p for p in db.get_all_pifs() if not p in get_bond_masters_of_pif(pif)]

    # loop through all the pifs on this host looking for one with
    #   other-config:peerdns = true, and one with
    #   other-config:default-route=true
    peerdns_pif = None
    defaultroute_pif = None
    for __pif in pifs_on_host:
        __pifrec = db.get_pif_record(__pif)
        __oc = __pifrec['other_config']
        if __oc.has_key('peerdns') and __oc['peerdns'] == 'true':
            if peerdns_pif == None:
                peerdns_pif = __pif
            else:
                log('Warning: multiple pifs with "peerdns=true" - choosing %s and ignoring %s' % \
                        (db.get_pif_record(peerdns_pif)['device'], __pifrec['device']))
        if __oc.has_key('defaultroute') and __oc['defaultroute'] == 'true':
            if defaultroute_pif == None:
                defaultroute_pif = __pif
            else:
                log('Warning: multiple pifs with "defaultroute=true" - choosing %s and ignoring %s' % \
                        (db.get_pif_record(defaultroute_pif)['device'], __pifrec['device']))

    # If no pif is explicitly specified then use the mgmt pif for
    # peerdns/defaultroute.
    if peerdns_pif == None:
        peerdns_pif = management_pif
    if defaultroute_pif == None:
        defaultroute_pif = management_pif

    is_dnsdev = peerdns_pif == pif
    is_gatewaydev = defaultroute_pif == pif

    if is_dnsdev or is_gatewaydev:
        fnetwork = ConfigurationFile("/etc/sysconfig/network")
        for line in fnetwork.readlines():
            if is_dnsdev and line.lstrip().startswith('DNSDEV='):
                fnetwork.write('DNSDEV=%s\n' % ipdev)
                is_dnsdev = False
            elif is_gatewaydev and line.lstrip().startswith('GATEWAYDEV='):
                fnetwork.write('GATEWAYDEV=%s\n' % ipdev)
                is_gatewaydev = False
            else:
                fnetwork.write(line)

        if is_dnsdev:
            fnetwork.write('DNSDEV=%s\n' % ipdev)
        if is_gatewaydev:
            fnetwork.write('GATEWAYDEV=%s\n' % ipdev)

        fnetwork.close()
        f.attach_child(fnetwork)

    return f

#
# Toplevel actions
#

def action_up(pif):
    pifrec = db.get_pif_record(pif)

    f = ipdev_configure_network(pif)

    bridge = bridge_name(pif)

    if bridge:
        pf = configure_pif(pif)
        f.attach_child(pf)

    f.close()

    # if there is a bridge using this pif then bring it down
    if bridge:
        bring_down_bridge(bridge)

    # Bring down any VLAN masters so that we can reconfigure the slave.
    vlan_masters = get_vlan_masters_of_pif(pif)
    for master in vlan_masters:
        name = pif_netdev_name(master)
        log("action_up: bring down %s" % (name))
        ifdown(name)

    # interface-reconfigure is never explicitly called to down a bond master.
    # However, when we are called to up a slave it is implicit that we are destroying the master.
    bond_masters = get_bond_masters_of_pif(pif)
    for master in bond_masters:
        master_bridge = bridge_name(master)
        # bring down master
        bring_down_interface(master, destroy=True)
        if master_bridge:
            bring_down_bridge(master_bridge, destroy=True)

    # No masters left - now its safe to reconfigure the slave.
    bring_down_interface(pif)

    try:
        f.apply()

        bring_up_interface(pif)
        if bridge:
            bring_up_bridge(bridge)

        # Update /etc/issue (which contains the IP address of the management interface)
        os.system("/sbin/update-issue")

        # Bring back any currently-attached VLAN masters (brought down above)
        for master in [v for v in vlan_masters if db.get_pif_record(v)['currently_attached']]:
            name = pif_netdev_name(master)
            log("action_up: bring up %s" % (name))
            ifup(name)

        f.commit()
    except Error, e:
        log("failed to apply changes: %s" % e.msg)
        f.revert()
        raise

def action_down(pif):
    bring_down_interface(pif, destroy=True)

def action_rewrite(pif):
    pifrec = db.get_pif_record(pif)

    f = ipdev_configure_network(pif)

    bridge = bridge_name(pif)

    if bridge:
        pf = configure_pif(pif)
        f.attach_child(pf)

    f.close()

    try:
        f.apply()
        f.commit()
    except Error, e:
        log("failed to apply changes: %s" % e.msg)
        f.revert()
        raise

# This is useful for reconfiguring the mgmt interface after having lost connectivity to the pool master
def action_force_rewrite(bridge, config):
    def getUUID():
        import subprocess
        uuid,_ = subprocess.Popen(['uuidgen'], stdout = subprocess.PIPE).communicate()
        return uuid.strip()

    # Notes:
    # 1. that this assumes the interface is bridged
    # 2. If --gateway is given it will make that the default gateway for the host

    # extract the configuration
    try:
        mode = config['mode']
        mac = config['mac']
        interface = config['device']
    except:
        raise Usage("Please supply --mode, --mac and --device")

    if mode == 'static':
        try:
            netmask = config['netmask']
            ip = config['ip']
        except:
            raise Usage("Please supply --netmask and --ip")
        try:
            gateway = config['gateway']
        except:
            gateway = None
    elif mode != 'dhcp':
        raise Usage("--mode must be either static or dhcp")

    if config.has_key('vlan'):
        is_vlan = True
        vlan_slave, vlan_vid = config['vlan'].split('.')
    else:
        is_vlan = False

    if is_vlan:
        raise Error("Force rewrite of VLAN not implemented")

    log("Configuring %s using %s configuration" % (bridge, mode))

    f = ConfigurationFile(dbcache_file)

    pif_uuid = getUUID()
    network_uuid = getUUID()

    f.write('<?xml version="1.0" ?>\n')
    f.write('<xenserver-network-configuration>\n')
    f.write('\t<pif ref="OpaqueRef:%s">\n' % pif_uuid)
    f.write('\t\t<network>OpaqueRef:%s</network>\n' % network_uuid)
    f.write('\t\t<management>True</management>\n')
    f.write('\t\t<uuid>%sPif</uuid>\n' % interface)
    f.write('\t\t<bond_slave_of>OpaqueRef:NULL</bond_slave_of>\n')
    f.write('\t\t<bond_master_of/>\n')
    f.write('\t\t<VLAN_slave_of/>\n')
    f.write('\t\t<VLAN_master_of>OpaqueRef:NULL</VLAN_master_of>\n')
    f.write('\t\t<VLAN>-1</VLAN>\n')
    f.write('\t\t<device>%s</device>\n' % interface)
    f.write('\t\t<MAC>%s</MAC>\n' % mac)
    f.write('\t\t<other_config/>\n')
    if mode == 'dhcp':
        f.write('\t\t<ip_configuration_mode>DHCP</ip_configuration_mode>\n')
        f.write('\t\t<IP></IP>\n')
        f.write('\t\t<netmask></netmask>\n')
        f.write('\t\t<gateway></gateway>\n')
        f.write('\t\t<DNS></DNS>\n')
    elif mode == 'static':
        f.write('\t\t<ip_configuration_mode>Static</ip_configuration_mode>\n')
        f.write('\t\t<IP>%s</IP>\n' % ip)
        f.write('\t\t<netmask>%s</netmask>\n' % netmask)
        if gateway is not None:
            f.write('\t\t<gateway>%s</gateway>\n' % gateway)
        f.write('\t\t<DNS></DNS>\n')
    else:
        raise Error("Unknown mode %s" % mode)
    f.write('\t</pif>\n')

    f.write('\t<network ref="OpaqueRef:%s">\n' % network_uuid)
    f.write('\t\t<uuid>InitialManagementNetwork</uuid>\n')
    f.write('\t\t<PIFs>\n')
    f.write('\t\t\t<PIF>OpaqueRef:%s</PIF>\n' % pif_uuid)
    f.write('\t\t</PIFs>\n')
    f.write('\t\t<bridge>%s</bridge>\n' % bridge)
    f.write('\t\t<other_config/>\n')
    f.write('\t</network>\n')
    f.write('</xenserver-network-configuration>\n')

    f.close()

    try:
        f.apply()
        f.commit()
    except Error, e:
        log("failed to apply changes: %s" % e.msg)
        f.revert()
        raise

def main(argv=None):
    global management_pif

    session = None
    pif_uuid = None
    pif = None

    force_interface = None
    force_management = False

    if argv is None:
        argv = sys.argv

    try:
        try:
            shortops = "h"
            longops = [ "pif=", "pif-uuid=",
                        "session=",
                        "force=",
                        "force-interface=",
                        "management",
                        "mac=", "device=", "mode=", "ip=", "netmask=", "gateway=",
                        "help" ]
            arglist, args = getopt.gnu_getopt(argv[1:], shortops, longops)
        except getopt.GetoptError, msg:
            raise Usage(msg)

        force_rewrite_config = {}

        for o,a in arglist:
            if o == "--pif":
                pif = a
            elif o == "--pif-uuid":
                pif_uuid = a
            elif o == "--session":
                session = a
            elif o == "--force-interface" or o == "--force":
                force_interface = a
            elif o == "--management":
                force_management = True
            elif o in ["--mac", "--device", "--mode", "--ip", "--netmask", "--gateway"]:
                force_rewrite_config[o[2:]] = a
            elif o == "-h" or o == "--help":
                print __doc__ % {'command-name': os.path.basename(argv[0])}
                return 0

        syslog.openlog(os.path.basename(argv[0]))
        log("Called as " + str.join(" ", argv))

        if len(args) < 1:
            raise Usage("Required option <action> not present")
        if len(args) > 1:
            raise Usage("Too many arguments")

        action = args[0]

        if not action in ["up", "down", "rewrite", "rewrite-configuration"]:
            raise Usage("Unknown action \"%s\"" % action)

        # backwards compatibility
        if action == "rewrite-configuration": action = "rewrite"

        if ( session or pif ) and pif_uuid:
            raise Usage("--session/--pif and --pif-uuid are mutually exclusive.")
        if ( session and not pif ) or ( not session and pif ):
            raise Usage("--session and --pif must be used together.")
        if force_interface and ( session or pif or pif_uuid ):
            raise Usage("--force is mutually exclusive with --session, --pif and --pif-uuid")
        if len(force_rewrite_config) and not (force_interface and action == "rewrite"):
            raise Usage("\"--force rewrite\" needed for --device, --mode, --ip, --netmask, and --gateway")

        global db
        if force_interface:
            log("Force interface %s %s" % (force_interface, action))

            if action == "rewrite":
                action_force_rewrite(force_interface, force_rewrite_config)
            elif action in ["up", "down"]:
                db = DatabaseCache(cache_file=dbcache_file)
                pif = db.get_pif_by_bridge(force_interface)
                management_pif = db.get_management_pif()

                if action == "up":
                    action_up(pif)
                elif action == "down":
                    action_down(pif)
            else:
                raise Error("Unknown action %s"  % action)
        else:
            db = DatabaseCache(session_ref=session)

            if pif_uuid:
                pif = db.get_pif_by_uuid(pif_uuid)

            if action == "rewrite" and not pif:
                pass
            else:
                if not pif:
                    raise Usage("No PIF given")

                if force_management:
                    # pif is going to be the management pif
                    management_pif = pif
                else:
                    # pif is not going to be the management pif.
                    # Search DB cache for pif on same host with management=true
                    pifrec = db.get_pif_record(pif)
                    management_pif = db.get_management_pif()

                log_pif_action(action, pif)

                if not check_allowed(pif):
                    return 0

                if action == "up":
                    action_up(pif)
                elif action == "down":
                    action_down(pif)
                elif action == "rewrite":
                    action_rewrite(pif)
                else:
                    raise Error("Unknown action %s"  % action)

            # Save cache.
            db.save(dbcache_file)

    except Usage, err:
        print >>sys.stderr, err.msg
        print >>sys.stderr, "For help use --help."
        return 2
    except Error, err:
        log(err.msg)
        return 1

    return 0

if __name__ == "__main__":
    rc = 1
    try:
        rc = main()
    except:
        ex = sys.exc_info()
        err = traceback.format_exception(*ex)
        for exline in err:
            log(exline)

    syslog.closelog()

    sys.exit(rc)
