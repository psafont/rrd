
(* ---------------------------------------------------------------------------------------------
   After recent db refactoring/improvements this layer is now almost entirely redundant.
   (It used to be where events were hooked into the db write calls, but since pooling split that
   fn is now performed directly in db_cache).
   
   Ideally DB_ACCESS should be coallesced with DB_CACHE and autogenerated db_actions should call
   through directly to the combined module.
   --------------------------------------------------------------------------------------------- *)

module type DB_ACCESS =
sig

  exception Read_missing_uuid of (*class*) string * (*ref*) string * (*uuid*) string
  exception Too_many_values of  (*class*) string * (*ref*) string * (*uuid*) string

  type db_access_record = (string * string) list * (string * (string list)) list

  val db_read : Context.t -> string -> string -> string -> string
  val db_update : Context.t -> string -> string -> string -> string -> unit
  val db_delete : Context.t -> string -> string -> unit
  val db_get_by_uuid : string -> string -> string
  val db_get_by_name_label : string -> string -> string list
  val db_get_all : string -> string list
  val db_read_set_ref : string -> string -> string -> string list
  val db_insert : Context.t -> string -> (string * string) list -> string -> unit
  val db_read_record : string -> string -> db_access_record
  val db_add_set : Context.t -> string -> string -> string -> string -> unit
  val db_remove_set : Context.t -> string -> string -> string -> string -> unit
  val db_add_map : Context.t -> string -> string -> string -> string -> string -> unit
  val db_remove_map : Context.t -> string -> string -> string -> string-> unit
  val find_refs_with_filter : string -> Db_filter_types.expr -> string list
  val db_read_records_where : string -> Db_filter_types.expr -> (string * db_access_record) list
end

module DB_Access : DB_ACCESS =
struct

  open Db_cache
  open Db_action_helper
  open Db_cache_types
  open Eventgen
  open Db_lock

  type db_access_record = (string * string) list * (string * (string list)) list
    
  exception Read_missing_uuid of (*class*) string * (*ref*) string * (*uuid*) string
  exception Too_many_values of  (*class*) string * (*ref*) string * (*uuid*) string

  (** Read single field on specified object *)
  let db_read tbl fld objref =
    DBCache.read_field tbl fld objref
	
  (** Update single field on specified object to fldvalue *)
  let db_update context tbl fldvalue fld objref =
      with_lock
	(fun ()->
	   DBCache.write_field context tbl objref fld fldvalue;
	)
	
  let db_read_records_where tbl expr =
    with_lock
      (fun ()->
	 DBCache.read_records_where tbl expr)

  (** Delete single row from tbl *)
  let db_delete context tbl objref =
    with_lock
      (fun ()->
	 DBCache.delete_row context tbl objref;
      )

  (** Return reference field from tbl that matches specified uuid *)
  let db_get_by_uuid (tbl: string) (uuid_val: string) : string = 
    match (DBCache.read_field_where
	     {table=tbl; return=reference;
	      where_field=uuid; where_value=uuid_val}) with
      | [] -> raise (Read_missing_uuid (tbl, "", uuid_val))
      | [r] -> r
      | _ -> raise (Too_many_values (tbl, "", uuid_val))
	  
  (** Return reference fields from tbl that matches specified name_label field *)
  let db_get_by_name_label tbl label = 
    DBCache.read_field_where
      {table=tbl; return=reference;
       where_field=(Escaping.escape_id ["name"; "label"]);
       where_value=label}
  
  (** Returns all references in tbl *)
  let db_get_all tbl = 
      DBCache.read_refs tbl
	
  (** Returns the references in (foreign key) fld on tbl; used to get values of ref-set fields *)
  let db_read_set_ref tbl fld objref =
    DBCache.read_set_ref {table=tbl; return=reference;
			  where_field=fld; where_value=objref}

  (** Insert kv pairs into table, creating row with new object reference, new_reference *)
  let db_insert context table kv new_reference = 
    with_lock
      (fun ()->
	 let kv = (reference, new_reference) :: kv in
	   DBCache.create_row context table kv new_reference;
      )
		
  (** get a record + set-refs from related table transactionally *)
  let db_read_record tbl objref =
    DBCache.read_record tbl objref
	
  (* The rest of the functions handle Sets and Maps via s-expressions ------------------------------------ *)

  let process_structured_field context (key,value) tbl fld objref proc_fn =
    with_lock
      (fun ()->
	 DBCache.process_structured_field context (key,value) tbl fld objref proc_fn;
      )

  (** add a key to a set *)
  let db_add_set context tbl fld objref key = 
    process_structured_field context (key,"") tbl fld objref AddSet
      
  (** remove a key from a set *)
  let db_remove_set context tbl fld objref key =
    process_structured_field context (key,"") tbl fld objref RemoveSet
          
  (** add a key, value pair to a map *)
  let db_add_map context tbl fld objref key value = 
    process_structured_field context (key,value) tbl fld objref AddMap
   
  (** Called in the generated code to remove a key from a map *)
  let db_remove_map context tbl fld objref key = 
    process_structured_field context (key,"") tbl fld objref RemoveMap

  (* Return a list of all the references for which the expression returns true. *)
  let find_refs_with_filter (tblname: string) (expr: Db_filter_types.expr) = 
    DBCache.find_refs_with_filter tblname expr

end
